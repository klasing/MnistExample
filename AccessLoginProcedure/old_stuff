#include <iostream>
#include <iomanip>
#include <conio.h>
#include <string>
#include <time.h>
#include <random>

//#include "HandleUserAccess.cpp"
#include "HandlerForRegister.hpp"

using namespace std;
//****************************************************************************
//*                     global
//****************************************************************************
string* Connect2SQLite::highestKeyValue = nullptr;

//****************************************************************************
//*                     generate_random_string
//****************************************************************************
inline string
    generate_random_string()
{
    const int RANDOM_CHARACTER_MAX = 16;
    string random_string = "";
    mt19937 eng(static_cast<unsigned long>(time(nullptr)));
    uniform_int_distribution<int> dist(65, 90);
    for (int i = 0; i < RANDOM_CHARACTER_MAX; i++)
        random_string += dist(eng);
    return random_string;
}
//****************************************************************************
//*                     get_string_from_user
//****************************************************************************
void get_string_from_user(
    string& input_from_user,
    const bool& echo_character = true)
{
    char substitute_character = '*';
    char ch = '\0';

    while ((ch = _getch()) != 13) {
        if (echo_character) cout << ch; else cout << substitute_character;
        input_from_user += ch;
    }
    cout << endl;
}

//****************************************************************************
//*                     get_input_from_user
//****************************************************************************
string get_input_from_user(
    const string& hdr,
    const int& width_header,
    const string& val,
    const int& width_value,
    const bool& echo_character = true)
{
    string substitute_user_password = "";
    substitute_user_password.insert(0, val.length(), '*');
    string input_from_user = "";

    cout
        << setw(width_header)
        << setiosflags(ios_base::left)
        << setfill('.')
        << hdr
        << setw(width_value)
        << setiosflags(ios_base::right)
        << setfill('.')
        << ((echo_character) ? val : substitute_user_password)
        << ": ";
    cout.unsetf(ios::adjustfield);

    get_string_from_user(input_from_user, echo_character);

    return input_from_user.length() > 0 ? input_from_user : val;
}

//****************************************************************************
//*                     get_user_access_params
//****************************************************************************
void get_user_access_params(
    string& user_email_address,
    string& user_password)
{
    const string HDR_USER_EMAIL_ADDRESS = "Email";
    const string HDR_USER_PASSWORD = "Password";

    int width_header =
        (HDR_USER_EMAIL_ADDRESS.length() > HDR_USER_PASSWORD.length()) ?
        HDR_USER_EMAIL_ADDRESS.length() :
        HDR_USER_PASSWORD.length();
    width_header += 3;
    int width_value = (user_email_address.length()) > user_password.length() ?
        user_email_address.length() :
        user_password.length();

    user_email_address = get_input_from_user(
        HDR_USER_EMAIL_ADDRESS,
        width_header,
        user_email_address,
        width_value,
        true
    );

    user_password = get_input_from_user(
        HDR_USER_PASSWORD,
        width_header,
        user_password,
        width_value,
        false
    );
}

//****************************************************************************
//*                     get_access_params_from_user
//****************************************************************************
void get_access_params_from_user(
    string& target,
    string& user_email_address,
    string& user_password)
{
    bool bProceed = true;
    int iChar = -1;

    while (bProceed) {
        cout << "Access" << endl;
        cout << "------" << endl;
        cout << " 1) Login" << endl;
        cout << " 2) Register" << endl;
        cout << " 3) Forgot password" << endl;
        cout << "Enter the number of a subject, or enter a zero to quit: ";

        cin >> iChar;
        // get rid of the new line character, to ensure the buffer sanity
        cin.get();

        switch (iChar) {
        case 1:
            target = "/login";
            get_user_access_params(
                user_email_address,
                user_password);
            bProceed = false;
            break;
        case 2:
            target = "/register";
            get_user_access_params(
                user_email_address,
                user_password);
            HandlerForRegister handlerForRegister(
                user_email_address,
                user_password
            );
            handlerForRegister.handle_register();
            bProceed = false;
            break;
        case 3:
            target = "/reset_password";
            get_user_access_params(
                user_email_address,
                user_password);
            bProceed = false;
            break;
        case 0:
            // the user wants to terminate
            bProceed = false;
            break;
        default:
            // the input, given by the user, is not an available option
            cout << "The entered number is not recognized, please try again." << endl;
            break;
        } // eof switch
    }
}

//****************************************************************************
//*                     main
//****************************************************************************
int main() {
    const string TARGET = "login";
    const string USER_EMAIL_ADDRESS = "guest@example.com";
    const string USER_PASSWORD = "anonymous";

    string target = TARGET;
    string user_email_address = USER_EMAIL_ADDRESS;
    string user_password = USER_PASSWORD;

    get_access_params_from_user(
        target,
        user_email_address,
        user_password
    );
    //handle_user_access(
    //  target,
    //  user_email_address,
    //  user_password
    //);

    return EXIT_SUCCESS;
}
//////////////////////////////////////////////////////////////////////////////
//#include "Connect2SQLite.hpp"
//
//****************************************************************************
//*                     main
//****************************************************************************
//int main() {
//  Connect2SQLite oSqlite;
//  oSqlite.openDb();
//  oSqlite.createTable();
//  oSqlite.insertDefaultUser();
//
//  oSqlite.selectFromTable("user_email_address", "guest@example.com");
//  // will fail
//  oSqlite.selectFromTable("user_email_address", "klasing1159@gmail.com");
//
//  oSqlite.selectFromTable(
//      "user_email_address", "guest@example.com",
//      "user_password", "anonymous");
//  // will fail
//  oSqlite.selectFromTable(
//      "user_email_address", "guest@example.com",
//      "user_password", "wrong password");
//
//  oSqlite.closeDb();
//  return EXIT_SUCCESS;
//}
//////////////////////////////////////////////////////////////////////////////
//#include <iostream>
//#include <iomanip>
//#include <conio.h>
//#include <string>
//
//#include "handle_user_access.hpp"
//#include "Connect2SQLite.cpp"
//
//using namespace std;
//// forward declaration
//const string ns_connect_to_sqlite::Model::NAME_DB = "http_server_async_ssl.db";
//
//namespace ns_http_client_async_ssl {
//  // prototype
//  inline void transcieve(const string&);
//}
//// static variable initialization
//int ns_connect_to_sqlite::Model::highestKeyValue = 0;
//
//namespace ns_http_server_async_ssl {
//  inline void transcieve(
//      const string payload,
//      const string target)
//  {
//      cout << payload << " " << target << endl;
//
//      std:string response_payload =
//          ns_handle_user_access::handle_user_access(
//              target,
//              payload);
//      string response = string("HTTP/1.1 200 OK\n")
//          + "Server: Boost.Beast/248\n"
//          + "Content-Type: text/html\n"
//          + "Content-Length: 15\n"
//          + "\n"
//          + response_payload;
//      ns_http_client_async_ssl::transcieve(response);
//  }
//}
//
//namespace ns_http_client_async_ssl {
//  inline void transcieve(const string& message) {
//      cout << message;
//  }
//
//  inline void run(
//      char const* mode,
//      char const* payload,
//      char const* host,
//      char const* port,
//      char const* target,
//      int version)
//  {
//      ns_http_server_async_ssl::transcieve(
//          payload,
//          target
//      );
//  }
//
//  inline int http_client_async_ssl(int argc, char* argv[]) {
//      auto const mode = argv[1];
//      auto const payload = argv[2];
//      auto const host = argv[3];
//      auto const port = argv[4];
//      auto const target = argv[5];
//      int version = argc == 7 && !std::strcmp("1.0", argv[6]) ? 10 : 11;
//
//      run(
//          mode,
//          payload,
//          host,
//          port,
//          target,
//          version);
//
//      return EXIT_SUCCESS;
//  }
//}
//
////****************************************************************************
////*                     get_string_from_user
////****************************************************************************
//void get_string_from_user(
//  string& input_from_user, const bool& echo_character = true)
//{
//  char substitute_character = '*';
//  char ch = '\0';
//
//  while ((ch = _getch()) != 13) {
//      if (echo_character) cout << ch; else cout << substitute_character;
//      input_from_user += ch;
//  }
//  cout << endl;
//}
//
////****************************************************************************
////*                     get_input_from_user
////****************************************************************************
//string get_input_from_user(
//  const string& hdr,
//  const int& width_header,
//  const string& val,
//  const int& width_value,
//  const bool& echo_character = true)
//{
//  string substitute_user_password = "";
//  substitute_user_password.insert(0, val.length(), '*');
//  string input_from_user = "";
//
//  cout
//      << setw(width_header)
//      << setiosflags(ios_base::left)
//      << setfill('.')
//      << hdr
//      << setw(width_value)
//      << setiosflags(ios_base::right)
//      << setfill('.')
//      << ((echo_character) ? val : substitute_user_password)
//      << ": ";
//  cout.unsetf(ios::adjustfield);
//
//  get_string_from_user(input_from_user, echo_character);
//
//  return input_from_user.length() > 0 ? input_from_user : val;
//}
//
////****************************************************************************
////*                     get_user_access_params
////****************************************************************************
//void get_user_access_params(
//  const string& target,
//  string& user_email_address,
//  string& user_password,
//  string& access_payload)
//{
//  const string HDR_USER_EMAIL_ADDRESS = "Email";
//  const string HDR_USER_PASSWORD = "Password";
//
//  int width_header =
//      (HDR_USER_EMAIL_ADDRESS.length() > HDR_USER_PASSWORD.length()) ?
//      HDR_USER_EMAIL_ADDRESS.length() :
//      HDR_USER_PASSWORD.length();
//  width_header += 3;
//  int width_value = (user_email_address.length()) > user_password.length() ?
//      user_email_address.length() :
//      user_password.length();
//
//  user_email_address = get_input_from_user(
//      HDR_USER_EMAIL_ADDRESS,
//      width_header,
//      user_email_address,
//      width_value,
//      true
//  );
//
//  user_password = get_input_from_user(
//      HDR_USER_PASSWORD,
//      width_header,
//      user_password,
//      width_value,
//      false
//  );
//
//  access_payload =
//      "email=" +
//      user_email_address +
//      "&password=" +
//      user_password;
//}
//
////****************************************************************************
////*                     get_access_params_from_user
////****************************************************************************
//void get_access_params_from_user(
//  string& target,
//  string& user_email_address,
//  string& user_password,
//  string& access_payload)
//{
//  bool bProceed = true;
//  int iChar = -1;
//
//  while (bProceed) {
//      cout << "Access" << endl;
//      cout << "------" << endl;
//      cout << " 1) Login" << endl;
//      cout << " 2) Register" << endl;
//      cout << " 3) Forgot password" << endl;
//      cout << "Enter the number of a subject, or enter a zero to quit: ";
//
//      cin >> iChar;
//      // get rid of the new line character, to ensure the buffer sanity
//      cin.get();
//
//      switch (iChar) {
//      case 1:
//          target = "/login";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 2:
//          target = "/register";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 3:
//          target = "/reset_password";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 0:
//          // the user wants to terminate
//          bProceed = false;
//          break;
//      default:
//          // the input, given by the user, is not an available option
//          cout << "The entered number is not recognized, please try again." << endl;
//          break;
//      } // eof switch
//  }
//}
//
////****************************************************************************
////*                     do_request
////****************************************************************************
//void do_request(
//  const string& request_mode,
//  const string& access_payload,
//  const string& ip_address,
//  const string& port_number,
//  const string& target_,
//  const string& version_)
//{
//  char cmd[] = "http-client-async-ssl";
//  char* mode = const_cast<char*>(request_mode.c_str());
//  char* payload = const_cast<char*>(access_payload.c_str());
//  char* host = const_cast<char*>(ip_address.c_str());
//  char* port = const_cast<char*>(port_number.c_str());
//  char* target = const_cast<char*>(target_.c_str());
//  char* version = const_cast<char*>(version_.c_str());;
//
//  int argc = 6;
//  char* argv[] = { cmd, mode, payload, host, port, target, version };
//  ns_http_client_async_ssl::http_client_async_ssl(argc, argv);
//}
//
////****************************************************************************
////*                     main
////****************************************************************************
//int main() {
//  const string IP_ADDRESS = "192.168.178.14";
//  const string PORT_NUMBER = "8080";
//  const string TARGET = "login";
//  const string HTTP_VERSION = "1.0";
//  const string USER_EMAIL_ADDRESS = "guest@example.com";
//  const string USER_PASSWORD = "anonymous";
//
//  string ip_address = IP_ADDRESS;
//  string port_number = PORT_NUMBER;
//  string target = TARGET;
//  string http_version = HTTP_VERSION;
//  string user_email_address = USER_EMAIL_ADDRESS;
//  string user_password = USER_PASSWORD;
//  string request_mode = "access";
//  string access_payload = "";
//
//  ns_connect_to_sqlite::Model model;
//  ns_connect_to_sqlite::View view;
//  model.setHandler(
//      &ns_connect_to_sqlite::View::messageChange);
//  ns_connect_to_sqlite::Controller controller(model, view);
//
//  if (controller.onLoad())
//      // database is successfully opened
//
//  get_access_params_from_user(
//      target,
//      user_email_address,
//      user_password,
//      access_payload
//  );
//  request_mode = "access";
//  do_request(
//      request_mode,
//      access_payload,
//      ip_address,
//      port_number,
//      target,
//      http_version);
//
//  controller.closeDb();
//
//  return EXIT_SUCCESS;
//}
//////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <iomanip>
#include <conio.h>
#include <string>
#include <time.h>
#include <random>

//#include "HandleUserAccess.cpp"
#include "HandlerForRegister.hpp"

using namespace std;
//****************************************************************************
//*                     global
//****************************************************************************
string* Connect2SQLite::highestKeyValue = nullptr;

//****************************************************************************
//*                     generate_random_string
//****************************************************************************
inline string
    generate_random_string()
{
    const int RANDOM_CHARACTER_MAX = 16;
    string random_string = "";
    mt19937 eng(static_cast<unsigned long>(time(nullptr)));
    uniform_int_distribution<int> dist(65, 90);
    for (int i = 0; i < RANDOM_CHARACTER_MAX; i++)
        random_string += dist(eng);
    return random_string;
}
//****************************************************************************
//*                     get_string_from_user
//****************************************************************************
void get_string_from_user(
    string& input_from_user,
    const bool& echo_character = true)
{
    char substitute_character = '*';
    char ch = '\0';

    while ((ch = _getch()) != 13) {
        if (echo_character) cout << ch; else cout << substitute_character;
        input_from_user += ch;
    }
    cout << endl;
}

//****************************************************************************
//*                     get_input_from_user
//****************************************************************************
string get_input_from_user(
    const string& hdr,
    const int& width_header,
    const string& val,
    const int& width_value,
    const bool& echo_character = true)
{
    string substitute_user_password = "";
    substitute_user_password.insert(0, val.length(), '*');
    string input_from_user = "";

    cout
        << setw(width_header)
        << setiosflags(ios_base::left)
        << setfill('.')
        << hdr
        << setw(width_value)
        << setiosflags(ios_base::right)
        << setfill('.')
        << ((echo_character) ? val : substitute_user_password)
        << ": ";
    cout.unsetf(ios::adjustfield);

    get_string_from_user(input_from_user, echo_character);

    return input_from_user.length() > 0 ? input_from_user : val;
}

//****************************************************************************
//*                     get_user_access_params
//****************************************************************************
void get_user_access_params(
    string& user_email_address,
    string& user_password)
{
    const string HDR_USER_EMAIL_ADDRESS = "Email";
    const string HDR_USER_PASSWORD = "Password";

    int width_header =
        (HDR_USER_EMAIL_ADDRESS.length() > HDR_USER_PASSWORD.length()) ?
        HDR_USER_EMAIL_ADDRESS.length() :
        HDR_USER_PASSWORD.length();
    width_header += 3;
    int width_value = (user_email_address.length()) > user_password.length() ?
        user_email_address.length() :
        user_password.length();

    user_email_address = get_input_from_user(
        HDR_USER_EMAIL_ADDRESS,
        width_header,
        user_email_address,
        width_value,
        true
    );

    user_password = get_input_from_user(
        HDR_USER_PASSWORD,
        width_header,
        user_password,
        width_value,
        false
    );
}

//****************************************************************************
//*                     get_access_params_from_user
//****************************************************************************
void get_access_params_from_user(
    string& target,
    string& user_email_address,
    string& user_password)
{
    bool bProceed = true;
    int iChar = -1;

    while (bProceed) {
        cout << "Access" << endl;
        cout << "------" << endl;
        cout << " 1) Login" << endl;
        cout << " 2) Register" << endl;
        cout << " 3) Forgot password" << endl;
        cout << "Enter the number of a subject, or enter a zero to quit: ";

        cin >> iChar;
        // get rid of the new line character, to ensure the buffer sanity
        cin.get();

        switch (iChar) {
        case 1:
            target = "/login";
            get_user_access_params(
                user_email_address,
                user_password);
            bProceed = false;
            break;
        case 2:
            target = "/register";
            get_user_access_params(
                user_email_address,
                user_password);
            HandlerForRegister handlerForRegister(
                user_email_address,
                user_password
            );
            handlerForRegister.handle_register();
            bProceed = false;
            break;
        case 3:
            target = "/reset_password";
            get_user_access_params(
                user_email_address,
                user_password);
            bProceed = false;
            break;
        case 0:
            // the user wants to terminate
            bProceed = false;
            break;
        default:
            // the input, given by the user, is not an available option
            cout << "The entered number is not recognized, please try again." << endl;
            break;
        } // eof switch
    }
}

//****************************************************************************
//*                     main
//****************************************************************************
int main() {
    const string TARGET = "login";
    const string USER_EMAIL_ADDRESS = "guest@example.com";
    const string USER_PASSWORD = "anonymous";

    string target = TARGET;
    string user_email_address = USER_EMAIL_ADDRESS;
    string user_password = USER_PASSWORD;

    get_access_params_from_user(
        target,
        user_email_address,
        user_password
    );
    //handle_user_access(
    //  target,
    //  user_email_address,
    //  user_password
    //);

    return EXIT_SUCCESS;
}
//////////////////////////////////////////////////////////////////////////////
//#include "Connect2SQLite.hpp"
//
//****************************************************************************
//*                     main
//****************************************************************************
//int main() {
//  Connect2SQLite oSqlite;
//  oSqlite.openDb();
//  oSqlite.createTable();
//  oSqlite.insertDefaultUser();
//
//  oSqlite.selectFromTable("user_email_address", "guest@example.com");
//  // will fail
//  oSqlite.selectFromTable("user_email_address", "klasing1159@gmail.com");
//
//  oSqlite.selectFromTable(
//      "user_email_address", "guest@example.com",
//      "user_password", "anonymous");
//  // will fail
//  oSqlite.selectFromTable(
//      "user_email_address", "guest@example.com",
//      "user_password", "wrong password");
//
//  oSqlite.closeDb();
//  return EXIT_SUCCESS;
//}
//////////////////////////////////////////////////////////////////////////////
//#include <iostream>
//#include <iomanip>
//#include <conio.h>
//#include <string>
//
//#include "handle_user_access.hpp"
//#include "Connect2SQLite.cpp"
//
//using namespace std;
//// forward declaration
//const string ns_connect_to_sqlite::Model::NAME_DB = "http_server_async_ssl.db";
//
//namespace ns_http_client_async_ssl {
//  // prototype
//  inline void transcieve(const string&);
//}
//// static variable initialization
//int ns_connect_to_sqlite::Model::highestKeyValue = 0;
//
//namespace ns_http_server_async_ssl {
//  inline void transcieve(
//      const string payload,
//      const string target)
//  {
//      cout << payload << " " << target << endl;
//
//      std:string response_payload =
//          ns_handle_user_access::handle_user_access(
//              target,
//              payload);
//      string response = string("HTTP/1.1 200 OK\n")
//          + "Server: Boost.Beast/248\n"
//          + "Content-Type: text/html\n"
//          + "Content-Length: 15\n"
//          + "\n"
//          + response_payload;
//      ns_http_client_async_ssl::transcieve(response);
//  }
//}
//
//namespace ns_http_client_async_ssl {
//  inline void transcieve(const string& message) {
//      cout << message;
//  }
//
//  inline void run(
//      char const* mode,
//      char const* payload,
//      char const* host,
//      char const* port,
//      char const* target,
//      int version)
//  {
//      ns_http_server_async_ssl::transcieve(
//          payload,
//          target
//      );
//  }
//
//  inline int http_client_async_ssl(int argc, char* argv[]) {
//      auto const mode = argv[1];
//      auto const payload = argv[2];
//      auto const host = argv[3];
//      auto const port = argv[4];
//      auto const target = argv[5];
//      int version = argc == 7 && !std::strcmp("1.0", argv[6]) ? 10 : 11;
//
//      run(
//          mode,
//          payload,
//          host,
//          port,
//          target,
//          version);
//
//      return EXIT_SUCCESS;
//  }
//}
//
////****************************************************************************
////*                     get_string_from_user
////****************************************************************************
//void get_string_from_user(
//  string& input_from_user, const bool& echo_character = true)
//{
//  char substitute_character = '*';
//  char ch = '\0';
//
//  while ((ch = _getch()) != 13) {
//      if (echo_character) cout << ch; else cout << substitute_character;
//      input_from_user += ch;
//  }
//  cout << endl;
//}
//
////****************************************************************************
////*                     get_input_from_user
////****************************************************************************
//string get_input_from_user(
//  const string& hdr,
//  const int& width_header,
//  const string& val,
//  const int& width_value,
//  const bool& echo_character = true)
//{
//  string substitute_user_password = "";
//  substitute_user_password.insert(0, val.length(), '*');
//  string input_from_user = "";
//
//  cout
//      << setw(width_header)
//      << setiosflags(ios_base::left)
//      << setfill('.')
//      << hdr
//      << setw(width_value)
//      << setiosflags(ios_base::right)
//      << setfill('.')
//      << ((echo_character) ? val : substitute_user_password)
//      << ": ";
//  cout.unsetf(ios::adjustfield);
//
//  get_string_from_user(input_from_user, echo_character);
//
//  return input_from_user.length() > 0 ? input_from_user : val;
//}
//
////****************************************************************************
////*                     get_user_access_params
////****************************************************************************
//void get_user_access_params(
//  const string& target,
//  string& user_email_address,
//  string& user_password,
//  string& access_payload)
//{
//  const string HDR_USER_EMAIL_ADDRESS = "Email";
//  const string HDR_USER_PASSWORD = "Password";
//
//  int width_header =
//      (HDR_USER_EMAIL_ADDRESS.length() > HDR_USER_PASSWORD.length()) ?
//      HDR_USER_EMAIL_ADDRESS.length() :
//      HDR_USER_PASSWORD.length();
//  width_header += 3;
//  int width_value = (user_email_address.length()) > user_password.length() ?
//      user_email_address.length() :
//      user_password.length();
//
//  user_email_address = get_input_from_user(
//      HDR_USER_EMAIL_ADDRESS,
//      width_header,
//      user_email_address,
//      width_value,
//      true
//  );
//
//  user_password = get_input_from_user(
//      HDR_USER_PASSWORD,
//      width_header,
//      user_password,
//      width_value,
//      false
//  );
//
//  access_payload =
//      "email=" +
//      user_email_address +
//      "&password=" +
//      user_password;
//}
//
////****************************************************************************
////*                     get_access_params_from_user
////****************************************************************************
//void get_access_params_from_user(
//  string& target,
//  string& user_email_address,
//  string& user_password,
//  string& access_payload)
//{
//  bool bProceed = true;
//  int iChar = -1;
//
//  while (bProceed) {
//      cout << "Access" << endl;
//      cout << "------" << endl;
//      cout << " 1) Login" << endl;
//      cout << " 2) Register" << endl;
//      cout << " 3) Forgot password" << endl;
//      cout << "Enter the number of a subject, or enter a zero to quit: ";
//
//      cin >> iChar;
//      // get rid of the new line character, to ensure the buffer sanity
//      cin.get();
//
//      switch (iChar) {
//      case 1:
//          target = "/login";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 2:
//          target = "/register";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 3:
//          target = "/reset_password";
//          get_user_access_params(
//              target,
//              user_email_address,
//              user_password,
//              access_payload);
//          bProceed = false;
//          break;
//      case 0:
//          // the user wants to terminate
//          bProceed = false;
//          break;
//      default:
//          // the input, given by the user, is not an available option
//          cout << "The entered number is not recognized, please try again." << endl;
//          break;
//      } // eof switch
//  }
//}
//
////****************************************************************************
////*                     do_request
////****************************************************************************
//void do_request(
//  const string& request_mode,
//  const string& access_payload,
//  const string& ip_address,
//  const string& port_number,
//  const string& target_,
//  const string& version_)
//{
//  char cmd[] = "http-client-async-ssl";
//  char* mode = const_cast<char*>(request_mode.c_str());
//  char* payload = const_cast<char*>(access_payload.c_str());
//  char* host = const_cast<char*>(ip_address.c_str());
//  char* port = const_cast<char*>(port_number.c_str());
//  char* target = const_cast<char*>(target_.c_str());
//  char* version = const_cast<char*>(version_.c_str());;
//
//  int argc = 6;
//  char* argv[] = { cmd, mode, payload, host, port, target, version };
//  ns_http_client_async_ssl::http_client_async_ssl(argc, argv);
//}
//
////****************************************************************************
////*                     main
////****************************************************************************
//int main() {
//  const string IP_ADDRESS = "192.168.178.14";
//  const string PORT_NUMBER = "8080";
//  const string TARGET = "login";
//  const string HTTP_VERSION = "1.0";
//  const string USER_EMAIL_ADDRESS = "guest@example.com";
//  const string USER_PASSWORD = "anonymous";
//
//  string ip_address = IP_ADDRESS;
//  string port_number = PORT_NUMBER;
//  string target = TARGET;
//  string http_version = HTTP_VERSION;
//  string user_email_address = USER_EMAIL_ADDRESS;
//  string user_password = USER_PASSWORD;
//  string request_mode = "access";
//  string access_payload = "";
//
//  ns_connect_to_sqlite::Model model;
//  ns_connect_to_sqlite::View view;
//  model.setHandler(
//      &ns_connect_to_sqlite::View::messageChange);
//  ns_connect_to_sqlite::Controller controller(model, view);
//
//  if (controller.onLoad())
//      // database is successfully opened
//
//  get_access_params_from_user(
//      target,
//      user_email_address,
//      user_password,
//      access_payload
//  );
//  request_mode = "access";
//  do_request(
//      request_mode,
//      access_payload,
//      ip_address,
//      port_number,
//      target,
//      http_version);
//
//  controller.closeDb();
//
//  return EXIT_SUCCESS;
//}
//////////////////////////////////////////////////////////////////////////////
//#include <string>
//#include <time.h>
//#include <random>
//
//#include "Connect2SQLite.hpp"
//#include "SmtpClient.cpp"
//
//using namespace std;
////****************************************************************************
////*                     protoype
////****************************************************************************
//string generate_random_string();
//
////****************************************************************************
////*                     handle_login
////****************************************************************************
//inline void handle_login(
//  Connect2SQLite& oSqlite,
//  const string& user_email_address,
//  const string& user_password
//  )
//{
//  int rc = -1;
//  rc = oSqlite.selectFromTable(
//      "user_email_address",
//      user_email_address
//  );
//  rc = oSqlite.selectFromTable(
//      "user_email_address",
//      user_email_address,
//      "user_password",
//      user_password
//  );
//}
//
////****************************************************************************
////*                     handle_register
////****************************************************************************
//inline void handle_register(
//  Connect2SQLite& oSqlite,
//  const string& user_email_address,
//  const string& user_password
//  )
//{
//  string random_string = generate_random_string();
//  //cout << random_string << endl;
//  string message_with_code = "code " + random_string;
//
//  smtp_client(
//      "klasingsmtp@gmail.com",
//      user_email_address,
//      "klasingsmtp@gmail.com",
//      user_email_address,
//      "no subject",
//      message_with_code);
//
//  //oSqlite.insertRegisterUser(
//  //  user_email_address,
//  //  user_password
//  //);
//}
//
////****************************************************************************
////*                     handle_reset_password
////****************************************************************************
//inline void handle_reset_password(
//  Connect2SQLite& oSqlite,
//  const string& user_email_address,
//  const string& user_password
//  )
//{
//
//}
//
////****************************************************************************
////*                     handle_user_access
////****************************************************************************
//inline void
//  handle_user_access(
//      const string& target,
//      const string& user_email_address,
//      const string& user_password
//  )
//{
//  Connect2SQLite oSqlite;
//  oSqlite.openDb();
//  oSqlite.createTable();
//  oSqlite.insertDefaultUser();
//
//  if (target == "/login")
//      handle_login(
//          oSqlite,
//          user_email_address,
//          user_password
//      );
//  if (target == "/register")
//      handle_register(
//          oSqlite,
//          user_email_address,
//          user_password
//      );
//  if (target == "/reset_password")
//      handle_reset_password(
//          oSqlite,
//          user_email_address,
//          user_password
//      );
//
//  oSqlite.closeDb();
//}
//
////****************************************************************************
////*                     generate_random_string
////****************************************************************************
//inline string
//  generate_random_string()
//{
//  const int RANDOM_CHARACTER_MAX = 16;
//  string random_string = "";
//  mt19937 eng(static_cast<unsigned long>(time(nullptr)));
//  uniform_int_distribution<int> dist(65, 90);
//  for (int i = 0; i < RANDOM_CHARACTER_MAX; i++)
//      random_string += dist(eng);
//  return random_string;
//}
//////////////////////////////////////////////////////////////////////////////
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#pragma comment(lib, "Ws2_32.lib")

#include <iostream>
#include <string>
#include <memory>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

using namespace std;
//****************************************************************************
//*                     read_socket
//****************************************************************************
inline void read_socket(SOCKET& sock) {
    int size_recv, total_size = 0;
    char chunk[BUFSIZ];
    char recvbuf[BUFSIZ] = "";

    memset(chunk, 0, BUFSIZ);  //clear the variable
    if ((size_recv = recv(sock, chunk, BUFSIZ, 0)) < 0)
        return;
    else
    {
        total_size += size_recv;
        strcat_s(recvbuf, BUFSIZ, chunk);
    }
    std::cout << recvbuf;
}

//****************************************************************************
//*                     read_socket_ssl
//****************************************************************************
inline void read_socket_ssl(SSL* ssl) {
    int size_recv, total_size = 0;
    char chunk[BUFSIZ];
    char recvbuf[BUFSIZ] = "";

    memset(chunk, 0, BUFSIZ);  //clear the variable
    if ((size_recv = SSL_read(ssl, chunk, BUFSIZ)) < 0)
        return;
    else
    {
        total_size += size_recv;
        chunk[total_size] = '\0';
        strcat_s(recvbuf, BUFSIZ, chunk);
        std::cout << recvbuf;
    }
}

//****************************************************************************
//*                     write_socket
//****************************************************************************
inline void write_socket(SOCKET& sock, const std::string& str) {
    char* buf = const_cast<char*>(str.c_str());
    int sended = 0;
    int all = strlen(buf);

    std::cout << str;
    while (all > 0) {
        sended = send(sock, buf, all, 0);
        *buf += sended;
        all -= sended;
    }
}

//****************************************************************************
//*                     write_socket_ssl
//****************************************************************************
inline void write_socket_ssl(SSL* ssl, const std::string& str) {
    char* buf = const_cast<char*>(str.c_str());
    int sended = 0;

    std::cout << str;
    sended = SSL_write(ssl, buf, strlen(buf));
}

//****************************************************************************
//*                     smtp_client
//****************************************************************************
inline int
    smtp_client(
        const string& mail_from,
        const string& rcpt_to,
        const string from,
        const string& to,
        const string& subject,
        const string& data
    )
{
    WSADATA wsaData = { 0 };
    int iResult = 0;

    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        std::cout << "WSAStartup failed: %d" << std::endl;
        return iResult;
    }

    SOCKET sock = INVALID_SOCKET;
    int iFamily = AF_INET;
    int iType = SOCK_STREAM;
    int iProtocol = 0;

    // Initialize socket
    sock = socket(iFamily, iType, iProtocol);
    if (sock == INVALID_SOCKET) {
        std::cout << "socket function failed with error = %d" << std::endl;
        return sock; // an INVALID_SOCKET value is returned
    }

    // Connect to server
    struct sockaddr_in server;
    char host_id[] = "74.125.142.109";
    if (inet_addr(host_id) != INADDR_NONE)
        server.sin_addr.s_addr = inet_addr(host_id);
    server.sin_family = AF_INET;
    server.sin_port = htons(587);
    if (connect(sock, (struct sockaddr*) & server, sizeof server) == -1)
    {
        std::cout << "Can't connect to server" << std::endl;
        return -1;
    }

    read_socket(sock);
    write_socket(sock, "EHLO smtp.gmail.com\r\n");
    read_socket(sock);
    write_socket(sock, "STARTTLS\r\n");
    read_socket(sock);

    // switch over to the Secure Socket Layer (SSL)*/
    SSL* ssl = nullptr;
    SSL_CTX* ctx;

    //Associate socket to SLL
    SSL_library_init();
    SSL_load_error_strings();
    ctx = SSL_CTX_new(TLSv1_client_method());
    ssl = SSL_new(ctx);
    SSL_set_fd(ssl, sock);

    // reconnect with SSL
    SSL_connect(ssl);
    write_socket_ssl(ssl, "EHLO smtp.gmail.com\r\n");
    read_socket_ssl(ssl);
    write_socket_ssl(ssl, "auth plain AGtsYXNpbmdzbXRwQGdtYWlsLmNvbQBwcHJ5cGRudGZxcWlpc3Ru\r\n");
    read_socket_ssl(ssl);

    // from/to part
    write_socket_ssl(ssl, "MAIL FROM:<" + mail_from + ">\r\n");
    read_socket_ssl(ssl);
    write_socket_ssl(ssl, "RCPT TO:<" + rcpt_to + ">\r\n");
    read_socket_ssl(ssl);

    // message data
    write_socket_ssl(ssl, "DATA\r\n");
    write_socket_ssl(ssl, "FROM:<" + from + ">\r\n");
    write_socket_ssl(ssl, "TO:<" + to + ">\r\n");
    write_socket_ssl(ssl, "SUBJECT:<" + subject + ">\r\n");
    write_socket_ssl(ssl, data + "\r\n");
    write_socket_ssl(ssl, "\r\n");
    write_socket_ssl(ssl, "\r\n");
    write_socket_ssl(ssl, ".\r\n");

    // start sending message to recipient
    write_socket_ssl(ssl, "QUIT\r\n");
    read_socket_ssl(ssl);

    return 0;
}
//////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <memory>

#include "CppSQLite3.h"

using namespace std;
//****************************************************************************
//*                     typedef
//****************************************************************************
typedef string id, user_email_address, user_password;
typedef tuple<id, user_email_address, user_password> tuple_user_data;
//****************************************************************************
//*                     Connect2SQLite
//****************************************************************************
class Connect2SQLite {
    const int DATA_MAX = 128;
    sqlite3* db = nullptr;
    int rc = -1;
    string sql = "";
    char* data = new char[DATA_MAX];
    char* pszErrMsg = 0;
    vector<tuple_user_data> vector_user_data;
    static string* highestKeyValue;
public:
    int openDb() {
        // open database
        rc = sqlite3_open("http_server_async_ssl.db", &db);
        if (rc) {
            cout << "Can't open database: " << sqlite3_errmsg(db) << endl;
            return EXIT_FAILURE;
        }
        else
            cout << "Database opened successfully." << endl;

        return EXIT_SUCCESS;
    }
    int closeDb() {
        // close database
        rc = sqlite3_close(db);
        if (rc) {
            cout << "Error closing database: " << sqlite3_errmsg(db) << endl;
            return EXIT_FAILURE;
        }
        else
            cout << "Table closed successfully." << endl;

        // clean up
        delete[] data;

        return EXIT_SUCCESS;
    }
    int createTable() {
        // create table
        sql =
            "CREATE TABLE IF NOT EXISTS user_access_login_data(" \
            "id                 INT PRIMARY KEY NOT NULL," \
            "user_email_address TEXT NOT NULL UNIQUE," \
            "user_password      TEXT NOT NULL" \
            ");";
        strcpy_s(data, DATA_MAX, "create table");
        // no data will be returned from this SQL execution
        return execute(sql, nullptr);
    }
    int insertDefaultUser() {
        // insert into table
        sql =
            "INSERT INTO user_access_login_data(id, user_email_address, user_password) " \
            "VALUES (1, 'guest@example.com', 'anonymous');";
        strcpy_s(data, DATA_MAX, "insert default user");
        // no data will be returned from this SQL execution
        return execute(sql, nullptr);
    }
    int selectFromTable(const string& colName, const string& value) {
        // select from table
        sql = string("SELECT * FROM user_access_login_data ")
            + "WHERE "
            + colName
            + " = "
            + "'" + value + "'"
            + ";";
        strcpy_s(data, DATA_MAX, "select from table");
        rc = execute(sql, &vector_user_data);
        if (vector_user_data.size() == 0) {
            cout << "no data found in database" << endl;
            rc = -1;
        }
        else
            show_data_in_vector();

        return rc;
    }
    int selectFromTable(
        const string& user_email_address, const string& user_email_address_value,
        const string& user_password, const string& user_password_value)
    {
        // select from table
        sql = string("SELECT * FROM user_access_login_data ")
            + "WHERE "
            + user_email_address
            + " = "
            + "'" + user_email_address_value + "'"
            + " AND "
            + user_password
            + " = "
            + "'" + user_password_value + "'"
            + ";";
        strcpy_s(data, DATA_MAX, "select from table");
        rc = execute(sql, &vector_user_data);
        if (vector_user_data.size() == 0) {
            cout << "no data found in database" << endl;
            rc = -1;
        }
        else
            show_data_in_vector();

        return rc;
    }
    int insertRegisterUser(
        const string& user_email_address,
        const string& user_password
        )
    {
        // find a value for the key of the tuple that is going
        // to be inserted
        sql = "SELECT max(ID) FROM COMPANY;";
        strcpy_s(data, DATA_MAX, "select max(ID) from table");
        rc = execute(sql, highestKeyValue);

        // insert into table
        sql =
            "INSERT INTO user_access_login_data(id, user_email_address, user_password) " \
            "VALUES (1, '" + user_email_address + "', '" + user_password + "');";
        strcpy_s(data, DATA_MAX, "insert register user");
        // no data will be returned from this SQL execution
        return execute(sql, nullptr);
    }
private:
    // returns the description of a SQL execution
    const char* get_data() const { return data; }
    int execute(const string& sql, const void* data) {
        // start every callback sequence with an empty vector
        vector_user_data.clear();
        int rc = sqlite3_exec(
            db,
            sql.c_str(),
            callback,
            (void*)data,
            &pszErrMsg
        );
        if (rc != SQLITE_OK) {
            cout << "SQL error: " << pszErrMsg << endl;
            sqlite3_free(pszErrMsg);
            return rc;
        }
        else
            // a description of the performed SQL execution
            cout << get_data() << endl;

        return rc;
    }
    static int
        callback(
            void* data,
            int argc,
            char** argv,
            char** aszColName)
    {
        string colName = *aszColName;
        if (colName == "max(ID)") {
            *Connect2SQLite::highestKeyValue = argv[0];
            return 0;
        }

        // store database tuple into a C++ tuple
        tuple_user_data new_tuple_user_data(
            static_cast<string>(argv[0]),
            static_cast<string>(argv[1]),
            static_cast<string>(argv[2])
        );
        // store C++ tuple into a vector
        static_cast<vector<tuple_user_data>*>(data)->
            push_back(new_tuple_user_data);
        return EXIT_SUCCESS;
    }
    void show_data_in_vector() {
        for (auto it = vector_user_data.begin();
            it < vector_user_data.end(); ++it) {
            tuple_user_data new_tuple_user_data = *it;
            cout << "ID.........: " << get<0>(new_tuple_user_data) << endl;
            cout << "Email......: " << get<1>(new_tuple_user_data) << endl;
            cout << "Password...: " << get<2>(new_tuple_user_data) << endl;
        }
    }
};
//////////////////////////////////////////////////////////////////////////////
//#pragma once
//// handle_user_access.hpp
//// 1) login
////    1.1) login is ok, if
////         user_email_address is on file and
////         user_password is correct
////    1.2) login is NOT ok, if
////         1.2.1) user_email_address is NOT on file
////                a user can register himself with the menu option: register
////         1.2.2) user_password is NOT correct
////                a user can try again or
////                can use the menu option: forgot password
//// 2) register
////    2.1) registration can be performed, if
////         user_email_address is NOT on filem then
////         the user_email_address/user_password will be written to file
////    2,2) registration can NOT be performed, if
////         user_email_address is on file, then
////         a user can use a different email address
////    a confirmation code will be send via email
////    the registration can be completed,
////    when the user has correctly entered the confirmation code
//// 3) forgot password
////    a password reset can be performed, if
////    user_email_address is on file, then
////    a confirmation code will be send via email
////    the password reset can be completed,
////    when the user has correctly entered the confirmation code
//
//#include <iostream>
//#include <tuple>
//#include <time.h>
//#include <random>
//
//using namespace std;
//namespace ns_handle_user_access {
//  inline void
//      generate_random_string()
//  {
//      const int RANDOM_CHARACTER_MAX = 16;
//      string random_string = "";
//      mt19937 eng(static_cast<unsigned long>(time(nullptr)));
//      uniform_int_distribution<int> dist(65, 90);
//      for (int i = 0; i < RANDOM_CHARACTER_MAX; i++)
//          random_string += dist(eng);
//      cout << random_string << endl;
//  }
//
//  inline string
//      handle_user_access(
//          const string& target,
//          const string& payload)
//  {
//      cout << "handle_user_access()" << endl;
//      cout << "-> POST message received" << endl;
//
//      // filter user_email_address
//      size_t sBegin, sEnd, sLength, sTemp;
//      sTemp = 0;
//      sBegin = payload.find_first_of("=", sTemp);
//      sEnd = (payload.find("&", sBegin) != std::string::npos) ?
//          (payload.find("&", sBegin) - 1) :
//          payload.length() - 1;
//      sLength = sEnd - sBegin;
//      sBegin++;
//      std::string user_email_address = payload.substr(sBegin, sLength);
//      // filter user_password
//      sTemp = sEnd;
//      sBegin = payload.find_first_of("=", sTemp);
//      sEnd = (payload.find("&", sBegin) != std::string::npos) ?
//          (payload.find("&", sBegin) - 1) :
//          payload.length() - 1;
//      sLength = sEnd - sBegin;
//      sBegin++;
//      std::string user_password = payload.substr(sBegin, sLength);
//
//      std::cout << user_email_address << " " << user_password << std::endl;
//      typedef tuple<string, string> tuple_user_data;
//      tuple_user_data user_data_on_file(
//          user_email_address,
//          user_password);
//
//      // see what kind of access is requested
//      if (target == "/login")
//          ;
//      if (target == "/register")
//          generate_random_string();
//      if (target == "/reset_password")
//          ;
//
//      std::string response_payload = target;
//      response_payload.erase(0, 1);
//      response_payload += " succeeded";
//
//      return response_payload;
//  }
//}
//////////////////////////////////////////////////////////////////////////////
#include <string>

#include "SmtpClient.cpp"
#include "Connect2SQLite.hpp"

using namespace std;
// prototype
inline string generate_random_string();

class HandlerForRegister {
    Connect2SQLite& oSqlite;
    string user_email_address_;
    string user_password_;
public:
    HandlerForRegister(
        string user_email_address,
        string user_password)
        : user_email_address_(user_email_address)
        , user_password_(user_password)
    {}
    void handle_register() {
        string generated_code = generate_random_string();
        string message_with_code = "code " + generated_code;
        string code_received_from_user;

        smtp_client(
            "klasingsmtp@gmail.com",
            user_email_address_,
            "klasingsmtp@gmail.com",
            user_email_address_,
            "no subject",
            message_with_code);

        cout << "Enter the code received by email: ";
        cin >> code_received_from_user;

        if (code_received_from_user == generated_code)
            oSqlite.insertRegisterUser(
                user_email_address_,
                user_password_
            );
    }
};
